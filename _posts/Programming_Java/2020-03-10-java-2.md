---
layout: post
title: 객체지향 프로그래밍 - 2
comments: true
categories : [Programming/Java]
tags: [Programming, Java]
---

<br><br>

# 객체지향 프로그래밍 - 2
---

<br>

## 오버로딩

- 같은 클래스 내에서 메서드 이름이 같음
- 매개변수의 개수 또는 타입이 달라야 함.

> 반환 타입은 오버로딩을 구현하는데 어무런 영향을 주지 못한다.

```java
public class Overloading {
    public static void main(String[] args) {
        OverloadingTest t = new OverloadingTest();
        System.out.println(t.add(3, 3));
        System.out.println(t.add(3, 3L));
        System.out.println(t.add(3L, 3));
        System.out.println(t.add(3L, 3L));
    }
}

class OverloadingTest {
    int add(int a, int b) {
        System.out.println("int add(int a, int b)");
        return a+b;
    }

    long add(int a, long b) {
        System.out.println("long add(int a, long b)");
        return a+b;
    }

    long add(long a, int b) {
        System.out.println("long add(long a, int b)");
        return a+b;
    }

    long add(long a, long b) {
        System.out.println("long add(long a, long b)");
        return a+b;
    }
}
```

---

## 가변인자(varargs)와 오버로딩

```java
public class VarArgs {
    public static void main(String[] args) {
        String[] strArr = { "100", "200", "300" };

        System.out.println(concatenate("", "100", "200", "300"));
        System.out.println(concatenate("-", strArr));
        System.out.println(concatenate(",", new String[]{"1", "2", "3"}));
        System.out.println("[" + concatenate(",", new String[0]) + "]");
        System.out.println("[" + concatenate(",") + "]");
    }

    static String concatenate(String delim, String... args) {
        String result = "";

        for(String str : args) {
            result += str + delim;
        }

        return result;
    }
}
```

---

## 생성자(Constructor)

- 생성자의 이름은 클래스의 이름과 같아야 함.
- 생성자는 리턴 값이 없음.

